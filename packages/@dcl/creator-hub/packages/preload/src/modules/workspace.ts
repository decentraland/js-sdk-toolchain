import { shell } from 'electron';
import type { Scene } from '@dcl/schemas';

import {
  type DependencyState,
  SortBy,
  type Project,
  type ProjectInfo,
} from '/shared/types/projects';
import { PACKAGES_LIST } from '/shared/types/pkg';
import { DEFAULT_DEPENDENCY_UPDATE_STRATEGY } from '/shared/types/settings';
import type { GetProjectsOpts, Template, Workspace } from '/shared/types/workspace';
import { FileSystemStorage } from '/shared/types/storage';

import type { Services } from '../services';

import { getScene, getRowsAndCols, parseCoords, updateSceneThumbnail } from './scene';
import { getDefaultScenesPath, getScenesPath } from './settings';

import { DEFAULT_THUMBNAIL, NEW_SCENE_NAME, EMPTY_SCENE_TEMPLATE_REPO } from './constants';
import { getProjectId } from './analytics';

export function initializeWorkspace(services: Services) {
  const { config, fs, ipc, path, pkg, npm } = services;

  // IMPORTANT: when './scene' get's moved to this same factory pattern, we should remove
  // the import for { getScene } and use it as "const scene = initializeScene(services)".
  // same approach goes for './settings'.

  /**
   * Returns whether or not the provided directory is a decentraland project or not
   */
  async function isDCL(_path: string) {
    try {
      await getScene(_path);
      return pkg.hasDependency(_path, '@dcl/sdk');
    } catch (_) {
      return false;
    }
  }

  /**
   * Returns whether or not the provided directory is empty or not
   */
  async function isEmpty(_path: string) {
    try {
      const files = await fs.readdir(_path);
      return files.length === 0;
    } catch (_) {
      return false;
    }
  }

  /**
   * Return whether or not the provided directory has a node_modules directory
   */
  async function hasNodeModules(_path: string) {
    const nodeModulesPath = path.join(_path, 'node_modules');
    return fs.exists(nodeModulesPath);
  }

  async function getOldProjectThumbnailPath(_path: string) {
    const workspaceConfigPath = await getConfigPath(_path);
    return path.join(workspaceConfigPath, 'images', 'project-thumbnail.png');
  }

  function getProjectThumbnailPath() {
    return path.join('assets', 'images', 'autogenerated-thumbnail.png');
  }

  async function getProjectThumbnailAsBase64(projectPath: string, scene?: Scene): Promise<string> {
    try {
      scene = scene ?? (await getScene(projectPath));
      const thumbnailPath = path.join(projectPath, scene.display?.navmapThumbnail || '');
      return (await fs.readFile(thumbnailPath)).toString('base64');
    } catch (e) {
      try {
        // if there is no thumbnail defined in scene.json, look for the one inside assets/hub/
        const thumbnailPath = path.join(projectPath, getProjectThumbnailPath());
        return (await fs.readFile(thumbnailPath)).toString('base64');
      } catch (_) {
        try {
          // if there is no thumbnail in assets/hub/, look for old one inside .editor/
          const thumbnailPath = await getOldProjectThumbnailPath(projectPath);
          return (await fs.readFile(thumbnailPath)).toString('base64');
        } catch (e) {
          // if none of the above, return a default thumbnail...
          console.warn(`Could not get project thumbnail for project in ${projectPath}`, e);
          return DEFAULT_THUMBNAIL;
        }
      }
    }
  }

  async function getOutdatedPackages(_path: string): Promise<DependencyState> {
    const outdated = await npm.getOutdatedDeps(_path, PACKAGES_LIST);
    return outdated as DependencyState;
  }

  async function getProject({
    path: _path,
    opts,
  }: {
    path: string;
    opts?: GetProjectsOpts;
  }): Promise<Project> {
    try {
      const [id, scene, stat, dependencyAvailableUpdates, infoFs] = await Promise.all([
        getProjectId(_path),
        getScene(_path),
        fs.stat(_path),
        opts?.omitOutdatedPackages ? Promise.resolve({}) : getOutdatedPackages(_path),
        getProjectInfoFs(_path),
      ]);
      const thumbnail = await getProjectThumbnailAsBase64(_path, scene);
      const layout = getRowsAndCols(scene.scene.parcels.map($ => parseCoords($)));
      const info = await infoFs.getAll();

      return {
        id,
        path: _path,
        title: scene.display?.title || 'Untitled scene',
        description: scene.display?.description,
        thumbnail,
        layout,
        scene: scene.scene,
        createdAt: Number(stat.birthtime),
        updatedAt: Number(stat.mtime),
        publishedAt: 0, // TODO: possible to get publishedAt from catalyst?
        size: stat.size,
        worldConfiguration: scene?.worldConfiguration,
        dependencyAvailableUpdates,
        info,
      };
    } catch (error: any) {
      throw new Error(`Could not get project in "${_path}": ${error.message}`);
    }
  }

  async function getPath() {
    const appHome = await getScenesPath();
    try {
      await fs.stat(appHome);
    } catch (error) {
      await fs.mkdir(appHome);
    }
    return appHome;
  }

  /**
   * Returns all decentraland projects in the provided directories (or the default one if no provided)
   */
  async function getProjects(
    paths: string | string[],
    opts?: GetProjectsOpts,
  ): Promise<[Project[], string[]]> {
    paths = Array.isArray(paths) ? paths : [paths];
    if (!paths.length) return [[], []];

    const promises: Promise<Project>[] = [];
    const missing: string[] = [];

    for (const _path of paths) {
      try {
        if (!(await fs.exists(_path))) {
          // _path doesn't exist
          missing.push(_path);
        } else if (await isDCL(_path)) {
          // _path is a project
          promises.push(getProject({ path: _path, opts }));
        } else {
          // _path is a directory with projects
          const files = await fs.readdir(_path);
          for (const dir of files) {
            try {
              const projectDir = path.join(_path, dir);
              if (await isDCL(projectDir)) {
                promises.push(getProject({ path: projectDir, opts }));
              }
              // eslint-disable-next-line no-empty
            } catch (_) {}
          }
        }
      } catch (_) {
        missing.push(_path);
      }
    }

    const projects = await Promise.all(promises);
    return [projects, missing];
  }

  /**
   * Fetches a list of templates and filters them by scene type.
   * @returns {Promise<Template[]>} A promise that resolves to an array of Template objects.
   * @throws {Error} If the fetch request fails or if the response is not in the expected format.
   */
  async function getTemplates(): Promise<Template[]> {
    try {
      const response = await fetch('https://studios.decentraland.org/api/get/resources');
      const templates: Template[] = (await response.json()) as Template[];
      return templates.filter($ => $.scene_type?.includes('Scene template'));
    } catch (e) {
      console.warn('[Preload] Could not get templates', e);
      return [];
    }
  }

  /**
   * Returns workspace info
   */
  async function getWorkspace(): Promise<Workspace> {
    const cfg = await config.getConfig();
    const [[projects, missing], templates] = await Promise.all([
      getProjects(cfg.workspace.paths, { omitOutdatedPackages: true }),
      getTemplates(),
    ]);

    return {
      sortBy: SortBy.NEWEST, // TODO: read from editor config file...
      projects,
      missing,
      templates,
      settings: {
        ...cfg.settings,
        // TODO: implement migrations for config file...
        dependencyUpdateStrategy:
          cfg.settings?.dependencyUpdateStrategy ?? DEFAULT_DEPENDENCY_UPDATE_STRATEGY,
        scenesPath: cfg.settings?.scenesPath ?? (await getDefaultScenesPath()),
      },
    };
  }

  async function getAvailable(_name: string = NEW_SCENE_NAME) {
    let availableName = _name;
    let counter = 2;
    const homePath = await getPath();
    let availablePath = path.join(homePath, availableName);
    while (await fs.exists(availablePath)) {
      availableName = `${_name} ${counter++}`;
      availablePath = path.join(homePath, availableName);
    }
    return { name: availableName, path: availablePath };
  }

  /**
   * Creates a new project with the given options.
   *
   * This function generates a new project folder with a unique name (if a project with the same name already exists)
   * and initializes it using a specified repository template. It also updates the projectâ€™s `scene.json` file and
   * adds the project path to the user's workspace configuration.
   *
   * @param {Object} [opts] - Options for creating the project.
   * @param {string} [opts.name] - The desired name for the project. Defaults to a new scene name.
   * @param {string} [opts.repo] - The repository to use as the template. Defaults to an empty scene template repository.
   * @returns {Promise<Project>} - A promise that resolves to the created project.
   */
  async function createProject(opts?: {
    name?: string;
    path?: string;
    repo?: string;
  }): Promise<{ path: string }> {
    const { name, path: projectPath } =
      opts?.path && opts?.name
        ? { name: opts.name, path: opts.path }
        : await getAvailable(opts?.name ?? NEW_SCENE_NAME);

    const templateRepo = opts?.repo ?? EMPTY_SCENE_TEMPLATE_REPO;

    try {
      const fullName = projectPath.endsWith(name) ? projectPath : path.join(projectPath, name);
      await fs.mkdir(fullName, { recursive: true });

      await ipc.invoke('cli.init', fullName, templateRepo);

      const scene = await getScene(fullName);
      scene.display!.title = name;

      // Remove worldConfiguration for non-empty templates
      if (templateRepo !== EMPTY_SCENE_TEMPLATE_REPO) {
        delete scene.worldConfiguration;
      }

      const sceneJsonPath = path.join(fullName, 'scene.json');
      await fs.writeFile(sceneJsonPath, JSON.stringify(scene, null, 2));

      await config.setConfig(config => {
        config.workspace.paths.push(fullName);
        return config;
      });

      return { path: fullName };
    } catch (error: any) {
      throw new Error(`Failed to create project "${name}": ${error.message}`);
    }
  }

  /**
   * Unlists a project directory from config.
   *
   * @param paths - The path or paths of the directories to be unlisted.
   * @returns A Promise that resolves when the directories have been unlisted.
   */
  async function unlistProjects(paths: string[]): Promise<void> {
    const pathSet = new Set(paths);
    await config.setConfig(
      ({ workspace }) => (workspace.paths = workspace.paths.filter($ => !pathSet.has($))),
    );
  }

  /**
   * Deletes a project directory and all its contents.
   *
   * @param _path - The path of the directory to be deleted.
   * @returns A Promise that resolves when the directory has been deleted.
   */
  async function deleteProject(_path: string): Promise<void> {
    await unlistProjects([_path]);
  }

  /**
   * Duplicates a project directory, creating a copy with a modified title.
   *
   * @param _path - The path of the directory to be duplicated.
   * @returns A Promise that resolves to the duplicated Project.
   */
  async function duplicateProject(_path: string): Promise<Project> {
    const scene = await getScene(_path);
    const available = await getAvailable(scene.display?.title || NEW_SCENE_NAME);

    await fs.cp(_path, available.path, { recursive: true });
    scene.display = { ...scene.display, title: available.name };
    await fs.writeFile(path.join(available.path, 'scene.json'), JSON.stringify(scene, null, 2));
    const project = await getProject({ path: available.path });
    return project;
  }

  async function isProjectPathAvailable(projectPath: string): Promise<boolean> {
    const cfg = await config.getConfig();
    const [projects] = await getProjects(cfg.workspace.paths, { omitOutdatedPackages: true });
    const projectPathNormalized = path.normalize(projectPath);
    const projectAlreadyExists = projects.find($ => $.path === projectPathNormalized);
    return !projectAlreadyExists;
  }

  async function selectNewProjectPath(title = 'Import project'): Promise<string | undefined> {
    const cfg = await config.getConfig();
    const [projectPath] = await ipc.invoke('electron.showOpenDialog', {
      title,
      properties: ['openDirectory', 'createDirectory'],
      defaultPath: cfg.settings.scenesPath,
    });

    return projectPath;
  }

  /**
   * Imports a project by allowing the user to select a directory.
   *
   * @returns A Promise that resolves to the imported project path.
   * @throws An error if the selected directory is not a valid project.
   */
  async function importProject(): Promise<Project | undefined> {
    const projectPath = await selectNewProjectPath();

    if (!projectPath) return undefined;

    const pathBaseName = path.basename(projectPath);
    const isAvailable = await isProjectPathAvailable(projectPath);

    if (!isAvailable) {
      throw new Error(`"${pathBaseName}" is already on the projects library`);
    }

    const isDCLProject = await isDCL(projectPath);

    if (!isDCLProject) {
      throw new Error(`"${pathBaseName}" is not a valid project`);
    }

    // update workspace on config file with new path
    await config.setConfig(config => config.workspace.paths.push(projectPath));

    const project = await getProject({ path: projectPath });
    return project;
  }

  /**
   * Reimports a project by allowing the user to select a new directory for a project whose path was deleted or renamed.
   *
   * @param _path - The current path of the project that needs to be reimported.
   * @returns A Promise that resolves to the reimported Project object.
   * @throws An error if the selected directory is not a valid project.
   */
  async function reimportProject(_path: string): Promise<Project | undefined> {
    const project = await importProject();
    if (project) await unlistProjects([_path]);
    return project;
  }

  /**
   * Saves a base64-encoded thumbnail image for a project and updates the scene metadata
   * if the current thumbnail is missing or invalid.
   *
   * @param {Object} params - The parameters needed to save the thumbnail.
   * @param {string} params.path - The path to the project directory.
   * @param {string} params.thumbnail - The base64-encoded thumbnail image data.
   * @returns {Promise<void>} A promise that resolves if everything went ok.
   */
  async function saveThumbnail({
    path: scenePath,
    thumbnail: thumbnailContent,
  }: {
    path: string;
    thumbnail: string;
  }): Promise<void> {
    const scene = await getScene(scenePath);
    const thumbnailPath = getProjectThumbnailPath();
    await fs.writeFile(path.join(scenePath, thumbnailPath), thumbnailContent, {
      encoding: 'base64',
    });

    // Check if the current thumbnail file exists
    // If the current thumbnail doesn't exist, update the scene.json to point to the new thumbnail
    const currentThumb = scene.display?.navmapThumbnail;
    const currentThumbPath = path.join(scenePath, path.normalize(currentThumb || ''));
    if (!(await fs.exists(currentThumbPath))) {
      await updateSceneThumbnail(scenePath, thumbnailPath);
    }
  }

  async function openFolder(_path: string) {
    const error = await shell.openPath(_path);
    if (error) throw new Error(error);
  }

  async function getConfigPath(_path: string) {
    return ipc.invoke('electron.getWorkspaceConfigPath', _path);
  }

  async function getProjectInfoFs(_path: string) {
    const configPath = await getConfigPath(_path);
    const projectInfoPath = path.join(configPath, 'project.json');
    const projectInfo = await FileSystemStorage.getOrCreate<ProjectInfo>(projectInfoPath);
    return projectInfo;
  }

  async function updateProjectInfo({ path, info }: { path: string; info: Partial<ProjectInfo> }) {
    const projectInfoFs = await getProjectInfoFs(path);
    const projectInfo = await projectInfoFs.getAll();
    await projectInfoFs.setAll({ ...projectInfo, ...info });
  }

  return {
    isDCL,
    isEmpty,
    hasNodeModules,
    getProjectThumbnailAsBase64,
    getOutdatedPackages,
    getProject,
    getPath,
    getProjects,
    getTemplates,
    getWorkspace,
    getAvailable,
    createProject,
    unlistProjects,
    deleteProject,
    duplicateProject,
    reimportProject,
    saveThumbnail,
    openFolder,
    getConfigPath,
    getProjectInfoFs,
    updateProjectInfo,
    importProject,
    isProjectPathAvailable,
    selectNewProjectPath,
  };
}
