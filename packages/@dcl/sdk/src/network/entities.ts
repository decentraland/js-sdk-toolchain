import {
  Entity,
  IEngine,
  NetworkEntity as _NetworkEntity,
  INetowrkEntity,
  NetworkParent as _NetworkParent,
  Transform as _Transform,
  SyncComponents as _SyncComponents,
  INetowrkParent,
  TransformComponent,
  ISyncComponents
} from '@dcl/ecs'
import { IProfile } from './message-bus-sync'

export type SyncEntity = (entityId: Entity, componentIds: number[], entityEnumId?: number) => void

export function entityUtils(engine: IEngine, profile: IProfile) {
  const NetworkEntity = engine.getComponent(_NetworkEntity.componentId) as INetowrkEntity
  const NetworkParent = engine.getComponent(_NetworkParent.componentId) as INetowrkParent
  const Transform = engine.getComponent(_Transform.componentId) as TransformComponent
  const SyncComponents = engine.getComponent(_SyncComponents.componentId) as ISyncComponents

  function syncEntity(entityId: Entity, componentIds: number[], entityEnumId?: number) {
    // Profile not initialized
    if (!profile?.networkId) {
      throw new Error('Profile not initialized. Called syncEntity inside the main() function.')
    }

    // If there is an entityEnumId, it means is the same entity for all the clients created on the main funciton.
    // So the networkId should be the same in all the clients to avoid re-creating this entity.
    // For this case we use networkId = 0.
    // If is not defined, then is a entity created in runtime (what we called dynamic/runtime entities).
    // We use the networkId generated by the user address to identify this entity through the network
    const networkEntity =
      entityEnumId !== undefined
        ? { entityId: entityEnumId as Entity, networkId: 0 }
        : { entityId, networkId: profile.networkId }
    NetworkEntity.createOrReplace(entityId, networkEntity)
    SyncComponents.createOrReplace(entityId, { componentIds })
  }

  function* getChilds(parent: Entity): Iterable<Entity> {
    const network = NetworkEntity.getOrNull(parent)
    if (network) {
      for (const [entity, parent] of engine.getEntitiesWith(NetworkParent)) {
        if (parent.entityId === network.entityId && parent.networkId === network.networkId) {
          yield entity
        }
      }
    }
  }

  function getFirstChild(parent: Entity): Entity | undefined {
    const childs = [...getChilds(parent)]
    return childs[0] ?? undefined
  }

  function getParent(child: Entity): Entity | undefined {
    const parent = NetworkParent.getOrNull(child)
    if (!parent) return undefined
    for (const [entity, network] of engine.getEntitiesWith(NetworkEntity)) {
      if (parent.networkId === network.networkId && parent.entityId === network.entityId) {
        return entity
      }
    }
    return undefined
  }
  function parentEntity(entity: Entity, parent: Entity) {
    const network = NetworkEntity.getOrNull(parent)
    if (!network) {
      throw new Error('Please call syncEntity on the parent before parentEntity fn')
    }

    // Create network parent component
    NetworkParent.createOrReplace(entity, network)

    // If we dont have a transform for this entity, create an empty one to send it to the renderer
    if (!Transform.getOrNull(entity)) {
      Transform.create(entity)
    }
  }
  return {
    syncEntity,
    getChilds,
    getParent,
    parentEntity,
    getFirstChild
  }
}
